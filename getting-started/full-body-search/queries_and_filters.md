查询和过滤器
==========

* [空搜索](empty-search.md)
* [查询DSL](query-dsl.md)
* [查询和过滤器](queries-and-filters.md)
* [更重要的查询和过滤器](most-important-queries-and-filters.md)
* [带过滤器的查询](combining-queries-with-filters.md)
* [验证查询](validating-queries.md)


实际上有两种DSL：查询DSL和过滤器DSL。查询条件和过滤器条件在本质上是相似的，但有不同的用途。

过滤器会对每一个文档问一个yes|no的问题，且只针对有精确值的字段：

* `create`日期是否在`2013`到`2014`年？
* `status`字段是否包含术语`published`？
* `lat_lon`字段是否在指定点的10km范围内？

查询和过滤器很像，不过会问这个问题：这个文档有多匹配？

一些使用查询查找文档的经典用法：

* 最匹配`full text search`的文档。
* 包含词`run`，有可能还匹配`runs`、`running`、`jog`或者`sprint`。
* 包含词`quick`、`brown`和`fox`，这些词离得越近，文档的相关度越大。
* 被标记了`lucen`、`search`或者`java`，打这几个标签的数量越多，文档的相关度越大。

A typical use for a query is to find documents


查询会计算每个文档和查询的相关度，将其分配为`_score`，之后使用它来对文档的相关性排序。全文搜索很少有完全“正确”的答案，因而很适合用相关性的概念来表达。

性能差异
---------

大多数过滤器条件的输出（匹配过滤器的文档列表），每个文档只占用1bit，因而很容易计算，而且易于在内存缓存。这些缓存的过滤器能被后续查询有效重用。

查询则不仅要找出匹配的文档，还要计算出每个文档的相关度，通常比过滤器要更重。另外,查询结果也是不可缓存的。

由于倒排索引的存在，一个简单的查询只匹配少量的文档，这和跨越数百万文档的缓存了的过滤器的表现相当或者更好。但总体而言，一个缓存的过滤器优于查询，而且会一直这样。

过滤器的目标就是减少通过查询检查的文档个数。

什么时候使用哪一个
---------------

作为一个通用法则，使用全文搜索或者任何影响相关度的条件时，使用查询；其他的则使用过滤器。


[« DSL](query-dsl.md)      [更重要的查询和过滤器 »](most-important-queries-and-filters.md)
